{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Setup Project Structure and Core Dependencies",
        "description": "Initialize the project directory structure, install necessary dependencies for MCP and testing, and configure the build system.",
        "details": "1. Create directories: `src/mcp`, `src/taskbridge`, `src/gemini_ext`, `tests/unit`, `tests/integration`. 2. Initialize `package.json` if missing or update it. 3. Install `@modelcontextprotocol/sdk` (or equivalent MCP library based on current standards) and testing libraries (e.g., `jest` or `mocha`). 4. Configure `tsconfig.json` for TypeScript support if applicable. 5. Create a `tasks.json` in the root if it doesn't exist, to serve as the source for task graph operations.",
        "testStrategy": "Run `npm install` and verify node_modules are present. Run a simple dummy test script to verify the test runner works.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Project Directory Structure",
            "description": "Create the required folder hierarchy for the project including source, testing, and extension folders.",
            "dependencies": [],
            "details": "Execute mkdir commands to create `src/mcp`, `src/taskbridge`, `src/gemini_ext`, `src/gating`, `tests/unit`, and `tests/integration`. Ensure parent directories are created if they do not exist.",
            "status": "pending",
            "testStrategy": "Verify the existence of the specific directories using a shell script or manual inspection.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Initialize Node.js Project Configuration",
            "description": "Set up the package.json file to manage project metadata, scripts, and dependencies.",
            "dependencies": [
              1
            ],
            "details": "Run `npm init -y` to generate a default `package.json`. Update the entry point, version, and description. Define initial placeholder scripts for `build` and `test` commands.",
            "status": "pending",
            "testStrategy": "Check if package.json exists in the root and contains valid JSON syntax.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Install Core Dependencies and MCP SDK",
            "description": "Install the Model Context Protocol SDK and necessary testing frameworks to support development.",
            "dependencies": [
              2
            ],
            "details": "Execute `npm install @modelcontextprotocol/sdk` for the core library. Install dev dependencies: `npm install --save-dev typescript @types/node jest ts-jest @types/jest`.",
            "status": "pending",
            "testStrategy": "Run `npm list @modelcontextprotocol/sdk` and `npm list jest` to confirm installation.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configure TypeScript Environment",
            "description": "Set up the TypeScript compiler configuration to ensure code quality and build standards.",
            "dependencies": [
              3
            ],
            "details": "Create `tsconfig.json` defining compiler options such as `target: ES2022`, `module: NodeNext`, `strict: true`, `outDir: ./dist`, and `rootDir: ./src`. Include exclude rules for node_modules.",
            "status": "pending",
            "testStrategy": "Run `npx tsc --version` and verify the config file is loaded without errors.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Initial Task Graph Data Source",
            "description": "Initialize the tasks.json file which acts as the local database for the task management system.",
            "dependencies": [
              2
            ],
            "details": "Create a file named `tasks.json` in the project root. Initialize it with a valid empty schema, such as `{ \"tasks\": [] }`, to ensure the task loader does not crash on empty input.",
            "status": "pending",
            "testStrategy": "Verify the file exists and contains valid, parseable JSON content.",
            "parentId": "undefined"
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "None needed.",
        "updatedAt": "2025-12-23T23:03:24.754Z"
      },
      {
        "id": "2",
        "title": "Implement Gating Verdict Standardization",
        "description": "Create the gating logic to standardize model outputs into machine-parseable verdicts.",
        "details": "1. Create `src/gating/verdict.ts` (or `.js`). 2. Define the `Verdict` interface/type with fields: `verdict` ('PASS'|'FAIL'|'ALLOW'|'BLOCK'), `confidence` (number), `reasoning` (string). 3. Implement a parsing function `parseVerdict(modelOutput: string): Verdict`. 4. Implement fallback logic for inconclusive outputs (e.g., return 'inconclusive' or fail-closed based on config). 5. Add strict header parsing as per PRD.",
        "testStrategy": "Unit tests with various raw string inputs (valid headers, missing headers, ambiguous text) to assert correct `Verdict` object generation.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Verdict Interfaces and Types",
            "description": "Initialize the file structure and define the TypeScript interfaces and types required for model verdicts.",
            "dependencies": [],
            "details": "Create `src/gating/verdict.ts`. Define the `VerdictStatus` type ('PASS' | 'FAIL' | 'ALLOW' | 'BLOCK') and the `Verdict` interface containing `verdict`, `confidence` (number), and `reasoning` (string).",
            "status": "pending",
            "testStrategy": "Check file existence and verify TypeScript compilation of the defined interfaces.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Strict Header Extraction Logic",
            "description": "Develop the logic to locate and extract relevant content chunks from raw model output based on defined headers.",
            "dependencies": [
              1
            ],
            "details": "Implement a helper function within `src/gating/verdict.ts` that uses regex or string matching to isolate the verdict section (e.g., looking for `[VERDICT]` or specific PRD-defined markers) from the full model response.",
            "status": "pending",
            "testStrategy": "Unit test with sample strings containing various headers to ensure correct content extraction.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Core Verdict Parsing Logic",
            "description": "Create the logic to map extracted string content to specific VerdictStatus types and parse confidence scores.",
            "dependencies": [
              1
            ],
            "details": "Implement the logic to normalize the extracted text (uppercase, trim) and match it against valid `VerdictStatus` values. extract numerical confidence values if they exist in the text format defined in the PRD.",
            "status": "pending",
            "testStrategy": "Unit tests with variations of 'Pass', 'pass', 'PASS', and confidence strings to ensure correct type mapping.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Fallback and Fail-Closed Mechanisms",
            "description": "Add safety logic to handle cases where the output is ambiguous, empty, or unparseable.",
            "dependencies": [
              3
            ],
            "details": "Enhance the parsing logic to accept a configuration object (or default constant) that dictates behavior when parsing fails (e.g., return a 'BLOCK' verdict by default for security). Handle 'inconclusive' scenarios.",
            "status": "pending",
            "testStrategy": "Unit tests providing garbage or empty input to verify the function returns the safe fallback verdict.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Finalize parseVerdict Export Function",
            "description": "Compose the extraction, parsing, and fallback logic into the main exported function.",
            "dependencies": [
              2,
              4
            ],
            "details": "Export `parseVerdict(modelOutput: string): Verdict`. Ensure it chains the header extraction, core parsing, and fallback handling sequentially to produce a valid `Verdict` object for any input string.",
            "status": "pending",
            "testStrategy": "Integration unit tests covering the full pipeline from raw model string to final JSON object.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "None needed.",
        "updatedAt": "2025-12-23T23:04:07.994Z"
      },
      {
        "id": "3",
        "title": "Implement Task Bridge: Load and Parse tasks.json",
        "description": "Develop the functionality to load and parse the local `tasks.json` file into a structured internal graph model.",
        "details": "1. Create `src/taskbridge/loader.ts`. 2. Define the `TaskGraph` interface mirroring the structure of `tasks.json` (nodes, edges/dependencies). 3. Implement `loadTasksJson(path: string): TaskGraph`. 4. Ensure it handles nested subtasks and validates the schema (ids, titles, dependency arrays).",
        "testStrategy": "Unit test `loadTasksJson` with a valid fixture `tasks.json` and an invalid one (circular dependency or missing fields) to verify successful parsing and error handling.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Task Graph Schema and Zod Validation",
            "description": "Define the TypeScript interfaces and Zod validation schemas required to strictly parse the tasks.json file structure.",
            "dependencies": [],
            "details": "Create `src/taskbridge/schemas.ts` (or define within `loader.ts`). Define the `TaskNode` and `TaskGraph` interfaces to mirror the expected JSON structure. Implement Zod schemas to validate fields such as `id`, `title`, and recursive `subtasks`. Ensure the validation logic handles both flat and nested task definitions.",
            "status": "pending",
            "testStrategy": "Unit test the Zod schemas with various JSON objects (valid, missing required fields, invalid types) to ensure strict type safety.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement File Loader and Cycle Detection",
            "description": "Develop the file loading mechanism and the graph traversal logic to detect circular dependencies and construct the internal model.",
            "dependencies": [
              1
            ],
            "details": "In `src/taskbridge/loader.ts`, implement the `loadTasksJson` function. Read the file from the disk, parse it using the schemas defined in the previous step, and flattening nested structures if necessary for the internal graph. Implement a Depth First Search (DFS) or topological sort algorithm to validate dependencies and ensure no circular references exist (e.g., A depends on B, B depends on A).",
            "status": "pending",
            "testStrategy": "Create test fixtures including a valid deep nested graph and an invalid graph with a circular dependency. Verify that the loader parses the valid one correctly and throws a specific error for the cycle.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break down the implementation into: 1. Schema definition and Zod validation setup. 2. Recursive graph loading and cycle detection logic.",
        "updatedAt": "2025-12-23T23:04:40.629Z"
      },
      {
        "id": "4",
        "title": "Implement MCP Server Skeleton",
        "description": "Set up the basic MCP server structure using the MCP SDK, ready to register tools.",
        "details": "1. Create `src/mcp/server.ts`. 2. Initialize the MCP server instance (using JSON-RPC over stdio or HTTP as per project conventions). 3. Implement `startServer(config)` function. 4. Set up an empty `registerTools` function or handler map. 5. Ensure the server handles the initialization handshake defined in the MCP spec.",
        "testStrategy": "Run the server script and verify it listens/runs without crashing. Use an MCP inspector or simple client to send an 'initialize' request and check the response.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Server File and Configuration Interface",
            "description": "Initialize the source file and define the configuration types needed for the MCP server.",
            "dependencies": [],
            "details": "Create `src/mcp/server.ts`. Import necessary classes from `@modelcontextprotocol/sdk`. Define a `ServerConfig` interface that includes optional parameters for logging or transport settings to be used by the start function.",
            "status": "pending",
            "testStrategy": "Check if the file exists and compiles without type errors regarding the imports.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Instantiate MCP Server Class",
            "description": "Initialize the core MCP server instance with the required metadata using the SDK.",
            "dependencies": [
              1
            ],
            "details": "In `src/mcp/server.ts`, instantiate the `Server` class (or `McpServer` depending on SDK version) providing the implementation name (e.g., 'gemini-flow-mcp') and version. Configure default capabilities for resources and tools.",
            "status": "pending",
            "testStrategy": "Unit test: Import the server instance and verify it has the correct name and version properties.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Transport Layer and startServer Function",
            "description": "Set up the Stdio transport mechanism to handle JSON-RPC communication.",
            "dependencies": [
              2
            ],
            "details": "Implement the `startServer(config?: ServerConfig)` function. Inside, instantiate `StdioServerTransport` and call the server's connect method with this transport to enable communication over standard input/output.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Define Tool Registration Placeholder",
            "description": "Create the structure for registering tools, keeping it empty for the skeleton implementation.",
            "dependencies": [
              2
            ],
            "details": "Implement a `registerTools` function or prepare a `ListToolsRequestSchema` handler within the server setup. For now, this function should return an empty list of tools but serve as the integration point for future tool tasks.",
            "status": "pending",
            "testStrategy": "Unit test: Call the registration function and verify it returns an empty array or registers no tools without throwing errors.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Finalize Entry Point and Handshake Verification",
            "description": "Combine the components into an executable entry point and verify initialization logic.",
            "dependencies": [
              3,
              4
            ],
            "details": "Add the main execution block (e.g., `if (require.main === module)`) to invoke `startServer`. specific logic to handle the initialization handshake is managed by the SDK, but error handling for the startup process must be added here.",
            "status": "pending",
            "testStrategy": "Integration test: Run the compiled script and pipe a valid JSON-RPC 'initialize' message to stdin, expecting a valid JSON-RPC response on stdout.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "None needed.",
        "updatedAt": "2025-12-23T23:05:05.723Z"
      },
      {
        "id": "5",
        "title": "Implement MCP Tool: list_workflows",
        "description": "Create the `list_workflows` tool to return available workflows from the local manifest.",
        "details": "1. In `src/mcp/tools.ts`, define the schema for `list_workflows`. 2. Implement `handleListWorkflows(args)` which: loads the manifest (mock or real `src/manifest`), normalizes the data into `WorkflowInfo` objects (ID, mode, prerequisites), and returns the array. 3. Register this tool in `src/mcp/server.ts`.",
        "testStrategy": "Unit test `handleListWorkflows` by mocking the manifest loader and asserting the returned JSON matches the expected `WorkflowInfo` schema.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define list_workflows Schema and Types",
            "description": "Define the Zod schema for tool validation and TypeScript interfaces for the workflow data structure.",
            "dependencies": [],
            "details": "In `src/mcp/tools.ts`, create the `ListWorkflowsSchema` (using Zod) for input validation. Define the `WorkflowInfo` interface to standardize the return object, ensuring fields like ID, mode, and prerequisites are typed correctly.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Manifest Data Access Layer",
            "description": "Create the utility functions required to read and parse the local workflow manifest file from the disk.",
            "dependencies": [
              1
            ],
            "details": "Implement a `loadManifest` function (likely in `src/manifest/index.ts`) that reads the file system for the manifest JSON. Include error handling for missing files or invalid JSON syntax to prevent server crashes.",
            "status": "pending",
            "testStrategy": "Unit test the loader with valid, invalid, and missing files.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement handleListWorkflows Logic",
            "description": "Develop the core handler function that orchestrates data retrieval and formatting for the tool execution.",
            "dependencies": [
              2
            ],
            "details": "Implement `handleListWorkflows(args)` in `src/mcp/tools.ts`. This function should invoke the manifest loader, map the raw data into the `WorkflowInfo` format defined in subtask 1, and return the result array.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Register list_workflows in MCP Server",
            "description": "Integrate the new tool definition and handler into the main MCP server setup to expose it to clients.",
            "dependencies": [
              3
            ],
            "details": "In `src/mcp/server.ts`, add `list_workflows` to the `ListTools` capability response. Update the `CallTool` request handler to switch on the tool name and execute `handleListWorkflows` when invoked.",
            "status": "pending",
            "testStrategy": "Verify via MCP inspector that the tool appears in the list.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Unit Test list_workflows Tool",
            "description": "Write comprehensive unit tests to ensure the tool handler functions correctly under various scenarios.",
            "dependencies": [
              3
            ],
            "details": "Create `tests/mcp/tools.test.ts`. Mock the manifest loading dependency to return controlled data sets (empty, populated, malformed) and assert that `handleListWorkflows` returns the expected output or errors.",
            "status": "pending",
            "testStrategy": "Run `npm test` and check for green results on the new suite.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "None needed.",
        "updatedAt": "2025-12-23T23:05:31.916Z"
      },
      {
        "id": "6",
        "title": "Implement MCP Tool: run_workflow",
        "description": "Create the `run_workflow` tool to execute a specific workflow and return results.",
        "details": "1. Define schema for `run_workflow` (inputs: `workflow_id`, `inputs`, `mode`, `artifactDir`). 2. Implement `handleRunWorkflow(args)`. 3. Logic: Validate `workflow_id`, resolve the runner (e.g., calling existing `cline` or `script` modules), execute the workflow, capture stdout/stderr/exitCode, and return a `RunResult` object. 4. Ensure artifact paths are included in the result.",
        "testStrategy": "Integration test: Mock the actual execution layer (e.g., shell command runner) and verify `handleRunWorkflow` returns a formatted `RunResult`.",
        "priority": "medium",
        "dependencies": [
          "5",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Input Validation and Runner Resolution",
            "description": "Implement the Zod schema validation for tool arguments and the logic to identify the correct executable runner.",
            "dependencies": [],
            "details": "Define `RunWorkflowArgs` schema using Zod covering `workflow_id`, `inputs`, `mode`, and `artifactDir`. Implement `resolveRunner(workflowId)` which looks up the workflow in the manifest and returns the command string and arguments needed to spawn the process. Handle validation errors gracefully.",
            "status": "pending",
            "testStrategy": "Unit test validation logic with invalid inputs and verify correct runner resolution for known workflow IDs.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Subprocess Execution Mechanism",
            "description": "Implement the mechanism to spawn the workflow process and reliably capture standard output and error streams.",
            "dependencies": [
              1
            ],
            "details": "Develop a helper function `executeCommand(cmd, args, env)` that uses `child_process.spawn`. It should collect stream data, handle process errors (e.g., failed to start), and return an object with exit code and output strings.",
            "status": "pending",
            "testStrategy": "Unit test with a mock script that prints to stdout/stderr and exits with specific codes to verify capturing works.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Result Aggregation and Artifact Handling",
            "description": "Combine execution outputs into the standardized RunResult format and verify the existence of expected artifacts.",
            "dependencies": [
              2
            ],
            "details": "Implement `handleRunWorkflow`'s final step: map the execution result to `RunResult`. Check the specified `artifactDir` or the workflow's output configuration to list generated files. Return the final JSON serializable object.",
            "status": "pending",
            "testStrategy": "Integration test where a dummy workflow creates a file, and the result is checked to ensure the file path is correctly listed in the `artifacts` array.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split this task into: 1. Input validation and execution environment setup (resolving runner). 2. Subprocess execution wrapper with stream capturing (stdout/stderr). 3. Result formatting and artifact path resolution.",
        "updatedAt": "2025-12-23T23:06:30.339Z"
      },
      {
        "id": "7",
        "title": "Implement MCP Tool: install_pack",
        "description": "Create the `install_pack` tool to bootstrap workflow files into a target repository.",
        "details": "1. Define schema for `install_pack` (inputs: `targetPath`, `selection`, `overwritePolicy`). 2. Implement `handleInstallPack(args)`. 3. Logic: Calculate file operations (copy/template), check for conflicts, apply changes based on policy, and return an installation report.",
        "testStrategy": "Integration test: Point the tool to a temporary directory. Verify that files are created/copied correctly and that the returned report is accurate.",
        "priority": "medium",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement File System Helper Functions",
            "description": "Develop the underlying utility functions required to manage file system operations, distinguishing between direct file copying and template rendering.",
            "dependencies": [],
            "details": "Create a module (e.g., `src/utils/file-ops.ts`) containing: 1. A function to safely create target directories recursively. 2. A `copyFile(src, dest)` function for static assets. 3. A `renderTemplate(src, dest, context)` function for files requiring variable substitution. Ensure proper error handling for I/O exceptions.",
            "status": "pending",
            "testStrategy": "Unit tests using a temporary directory or mocked file system to verify that files are copied correctly and templates are rendered with provided variables.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Conflict Detection and Policy Logic",
            "description": "Develop the orchestration logic for the `install_pack` tool that detects file conflicts and applies the user-defined overwrite policy.",
            "dependencies": [
              1
            ],
            "details": "Implement `handleInstallPack`. The logic must: 1. Check if files in the selected pack already exist in the `targetPath`. 2. Apply the `overwritePolicy` (e.g., 'overwrite', 'skip', 'abort') to resolve conflicts. 3. Invoke the FS helpers to perform the operations. 4. Return a structured report summarizing actions taken (created, updated, skipped).",
            "status": "pending",
            "testStrategy": "Integration scenarios: Run against a directory with pre-existing files to ensure 'skip' preserves them and 'overwrite' replaces them. Verify the output report matches the actual file system state.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Divide into: 1. File system operation helper (copy vs template render). 2. Conflict detection and overwrite policy logic.",
        "updatedAt": "2025-12-23T23:07:42.632Z"
      },
      {
        "id": "8",
        "title": "Implement Task Bridge: Import to gemini-flow",
        "description": "Create the logic to convert the internal Task Graph into gemini-flow compatible task structures.",
        "details": "1. Create `src/taskbridge/importer.ts`. 2. Implement `importToGeminiFlow(graph, opts)`. 3. Logic: Iterate through graph nodes, generate stable IDs (e.g., hashing or namespacing), map dependencies to gemini-flow's format, and store the ID mapping in memory or a file. 4. Ensure idempotency (running twice updates state but doesn't duplicate tasks).",
        "testStrategy": "Unit test: Feed a known `TaskGraph` and assert the output object matches gemini-flow's task structure (mocking gemini-flow types if necessary).",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Stable ID Generation and Idempotency Mapping",
            "description": "Develop the mechanism to generate deterministic IDs for tasks and maintain a state map to ensure idempotency.",
            "dependencies": [],
            "details": "Create helper functions within `src/taskbridge/importer.ts` to generate stable IDs (using hashing of task names or properties). Implement a mapping structure (Internal ID <-> External Stable ID) that checks if a task has already been processed to prevent duplicates during the import process.",
            "status": "pending",
            "testStrategy": "Unit test ensuring that identical task inputs produce identical IDs across different execution contexts.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Graph Transformation for Gemini-Flow Import",
            "description": "Create the logic to traverse the internal task graph and convert it into the gemini-flow compatible structure.",
            "dependencies": [
              1
            ],
            "details": "Implement the `importToGeminiFlow` function in `src/taskbridge/importer.ts`. This function should iterate over graph nodes, apply the stable IDs generated in the previous step, map internal parent/child relationships to the external format's dependency syntax, and produce the final import object.",
            "status": "pending",
            "testStrategy": "Feed a known directed acyclic graph (DAG) into the function and assert that the output JSON strictly matches the gemini-flow schema and dependency structure.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into: 1. ID generation and mapping strategy (ensuring stability). 2. Graph transformation logic to map internal dependencies to external format.",
        "updatedAt": "2025-12-23T23:08:23.461Z"
      },
      {
        "id": "9",
        "title": "Implement Task Bridge: Export from gemini-flow",
        "description": "Create the logic to export the current status of tasks from gemini-flow back to a JSON format.",
        "details": "1. Create `src/taskbridge/exporter.ts`. 2. Implement `exportFromGeminiFlow(opts)`. 3. Logic: Retrieve current task states (mocking the gemini-flow query interface if needed), join with the stored ID mapping from the import step, and serialize to a JSON file matching the PRD's 'Task Graph Snapshot' requirement.",
        "testStrategy": "Integration test: Simulate a gemini-flow state with some completed tasks, run the export, and verify the output JSON correctly reflects the completion status.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement External State Query Interface",
            "description": "Create the interface and mock implementation to fetch current task states from the external gemini-flow system.",
            "dependencies": [],
            "details": "Define a provider interface in `src/taskbridge/provider.ts` for retrieving task status. Implement a mock version that simulates the gemini-flow API response, returning a map of External IDs to their current execution status (e.g., COMPLETED, FAILED, RUNNING) to allow development without the live system.",
            "status": "pending",
            "testStrategy": "Unit test the provider to ensure it returns valid status objects and handles simulation errors gracefully.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement State Reconciliation and JSON Export",
            "description": "Develop the logic to merge external states with internal ID mappings and generate the snapshot file.",
            "dependencies": [
              1
            ],
            "details": "Implement `exportFromGeminiFlow` in `src/taskbridge/exporter.ts`. Load the previously saved ID mapping file. Match external statuses retrieved from the provider (from subtask 1) to internal Task IDs. Construct the final `TaskGraphSnapshot` object and write it to disk as JSON.",
            "status": "pending",
            "testStrategy": "Integration test using a mocked ID map and mocked provider response to verify the output JSON structure accurately reflects the merged state.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Divide into: 1. Mocking/implementing the external state query interface. 2. Reconciliation logic to merge external status updates back into the internal task model.",
        "updatedAt": "2025-12-23T23:08:52.216Z"
      },
      {
        "id": "10",
        "title": "Implement Gemini CLI Extension Manifest and Wrappers",
        "description": "Package the MCP tools as a Gemini CLI extension for user-friendly command invocation.",
        "details": "1. Create `src/gemini_ext/gemini-extension.json`. 2. Define commands `pack list` and `pack run`. 3. Implement wrapper functions in `src/gemini_ext/commands.ts` that internally call the MCP tools (`list_workflows`, `run_workflow`). 4. Ensure proper exit code propagation and output formatting for the CLI user.",
        "testStrategy": "Manual/E2E verification (simulated): Verify that the manifest is valid JSON and that the wrapper functions correctly construct the MCP tool calls.",
        "priority": "low",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Gemini Extension Manifest",
            "description": "Define the extension metadata and command mappings in the extension manifest file.",
            "dependencies": [],
            "details": "Create `src/gemini_ext/gemini-extension.json`. Define properties such as `publisher`, `name`, and `version`. Explicitly register the commands `pack list` and `pack run`, pointing them to the extension's entry point script.",
            "status": "pending",
            "testStrategy": "Verify that the JSON file is valid and correctly recognized by the Gemini CLI loading mechanism (if available) or matches the schema definition.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Scaffold Command Entry Point",
            "description": "Set up the main entry point for the extension that routes arguments to specific handlers.",
            "dependencies": [
              1
            ],
            "details": "Create `src/gemini_ext/commands.ts`. Implement a main execution function that acts as the CLI entry point. Add logic to parse `process.argv` to distinguish between `pack list` and `pack run` commands and route them to empty placeholder functions.",
            "status": "pending",
            "testStrategy": "Run the script with different arguments and verify it logs the correct intended route (e.g., 'Routing to list handler').",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Pack List Wrapper",
            "description": "Implement the specific logic for the `pack list` command to invoke the internal list workflows functionality.",
            "dependencies": [
              2
            ],
            "details": "In `src/gemini_ext/commands.ts`, implement the handler for `pack list`. This function should instantiate the MCP tool interface, call `list_workflows`, and write the resulting list of workflows to `stdout`.",
            "status": "pending",
            "testStrategy": "Unit test the handler by mocking the MCP tool call and asserting that the output is written to the console correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Pack Run Wrapper",
            "description": "Implement the specific logic for the `pack run` command to invoke the internal run workflow functionality.",
            "dependencies": [
              2
            ],
            "details": "In `src/gemini_ext/commands.ts`, implement the handler for `pack run`. Ensure it accepts necessary arguments (like workflow ID), passes them to the underlying MCP tool `run_workflow`, and handles the execution flow.",
            "status": "pending",
            "testStrategy": "Unit test the handler with mock arguments to ensure parameters are correctly passed to the MCP tool function.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Finalize CLI Output and Error Handling",
            "description": "Ensure the CLI returns correct exit codes and formats output consistently for the user.",
            "dependencies": [
              3,
              4
            ],
            "details": "Refine `src/gemini_ext/commands.ts` to add global error handling blocks. Map internal exceptions to appropriate non-zero exit codes (e.g., `process.exit(1)`). Ensure successful executions return exit code 0 and format JSON output for readability.",
            "status": "pending",
            "testStrategy": "Simulate error conditions (e.g., tool failure) and verify the process exits with a non-zero code and prints an error message to stderr.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "None needed.",
        "updatedAt": "2025-12-23T23:09:14.406Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-23T23:09:14.406Z",
      "taskCount": 10,
      "completedCount": 10,
      "tags": [
        "master"
      ]
    }
  }
}