{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Project Structure and Implement Manifest Module",
        "description": "Set up the repository structure and implement the Manifest module to define workflow metadata and the catalog API.",
        "details": "Create the directory structure: `src/{manifest,install,cline,git,github,gating,render,report}`. Implement `src/manifest/index.ts` exporting `loadManifest`, `listWorkflows`, and `getWorkflow`. Define the `WorkflowInfo` interface including id, name, mode, prerequisites, inputs, and outputs. Create a default JSON/Object registry of the MVP workflows (PR review, Changelog, Pre-commit, Lint sweep) within the manifest.",
        "testStrategy": "Unit tests: Validate `loadManifest` returns the correct schema. Test `getWorkflow` with valid and invalid IDs. verify `listWorkflows` returns all defined entries.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize TypeScript Project and Directory Structure",
            "description": "Initialize the Node.js project, configure TypeScript settings, and create the required source directory hierarchy.",
            "dependencies": [],
            "details": "Initialize a new package.json and install TypeScript. Configure `tsconfig.json` for strict typing. Create the directory tree `src/{manifest,install,cline,git,github,gating,render,report}`. Set up ESLint and Prettier for code quality.",
            "status": "pending",
            "testStrategy": "Verify the directory structure exists on the filesystem and that a simple `tsc` build command runs without configuration errors."
          },
          {
            "id": 2,
            "title": "Define WorkflowInfo Interfaces and Types",
            "description": "Define the TypeScript interfaces and types required for the Manifest module and the workflow registry data structure.",
            "dependencies": [
              1
            ],
            "details": "Create `src/manifest/types.ts`. Define the `WorkflowInfo` interface including properties for `id`, `name`, `mode`, `prerequisites`, `inputs`, and `outputs`. Define helper types for the workflow registry object to ensure type safety.",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": 3,
            "title": "Implement Manifest Module and Populate MVP Registry",
            "description": "Implement the core manifest logic and populate the internal registry with the defined MVP workflows.",
            "dependencies": [
              2
            ],
            "details": "Implement `src/manifest/index.ts`. Export `loadManifest`, `listWorkflows`, and `getWorkflow`. Create a constant registry object containing the metadata for PR review, Changelog, Pre-commit, and Lint sweep workflows.",
            "status": "pending",
            "testStrategy": "Unit tests: Call `listWorkflows` to verify 4 items are returned. Call `getWorkflow('pr-review')` and verify the returned object matches the expected schema."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Render and Report Modules",
        "description": "Develop the foundation modules for prompt templating and artifact reporting/logging.",
        "details": "1. `src/render`: Implement `renderPrompt(templateId, data)` and `renderWorkflowMd` using a lightweight template engine (e.g., mustache or template literals). Store templates in `src/render/templates`. \n2. `src/report`: Implement `writeArtifact(path, content)` to save logs/outputs atomically to a defined artifacts directory (e.g., `.clinerules/artifacts` or `.git/cline-artifacts`). Implement `formatSummary` and `formatJson` for standardized output.",
        "testStrategy": "Unit tests: Verify templates render correctly with provided data context. Test `writeArtifact` creates files and handles path creation. Mock file system writes for isolation.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement src/render Templating Module",
            "description": "Develop the rendering logic to handle prompt interpolation and workflow markdown generation using a lightweight template engine.",
            "dependencies": [],
            "details": "Create `src/render/index.ts`. Implement `renderPrompt(templateId, data)` to load templates from `src/render/templates` and substitute variables. Implement `renderWorkflowMd` for workflow documentation. Choose a minimal templating solution (e.g., Mustache or native template literals) to keep overhead low.",
            "status": "pending",
            "testStrategy": "Unit tests: Create dummy templates and verify that `renderPrompt` correctly interpolates provided data object keys into the string."
          },
          {
            "id": 2,
            "title": "Implement src/report Artifact Management Module",
            "description": "Create the reporting module responsible for atomic file I/O and standardizing log formats for JSON and Markdown.",
            "dependencies": [],
            "details": "Create `src/report/index.ts`. Implement `writeArtifact(relativePath, content)` to securely write files to the artifact directory (e.g., `.clinerules/artifacts`), ensuring parent directories exist and using atomic write patterns. Implement `formatSummary` and `formatJson` helper functions.",
            "status": "pending",
            "testStrategy": "Integration tests: Verify `writeArtifact` creates files in a temp directory and handles non-existent subdirectories. Unit tests: Verify JSON and Summary formatters produce expected string output."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Git and Cline Execution Wrappers",
        "description": "Create wrappers for Git operations and the Cline CLI to enable headless and interactive execution.",
        "details": "1. `src/git`: Implement `getStagedDiff`, `getRangeDiff`, and `getCommitLog` using `child_process.exec`. Ensure output is captured reliably. \n2. `src/cline`: Implement `runHeadless(prompt, opts)` which spawns `cline task new` and monitors output. Implement `runInteractive` for standard flows. Create `followTask` to attach to running instances via `cline task view`.",
        "testStrategy": "Integration tests: Use a temporary git repository to verify diff extraction. Mock the `cline` binary to verify command arguments and output capturing logic.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Git Core Wrapper and Commit Log Retrieval",
            "description": "Initialize the Git module and implement the base execution helper and commit log retrieval functionality.",
            "dependencies": [],
            "details": "Create `src/git/index.ts`. Implement a reusable `execGit` function wrapping `child_process.exec` with proper `maxBuffer` handling and error management. Implement `getCommitLog(count)` to retrieve formatted git history.",
            "status": "pending",
            "testStrategy": "Create a temporary git repository, make commits, and verify `getCommitLog` returns the expected messages."
          },
          {
            "id": 2,
            "title": "Implement Git Diff Extraction Functions",
            "description": "Develop functions to extract staged and range-based diffs for context generation.",
            "dependencies": [
              1
            ],
            "details": "Implement `getStagedDiff` (wrapping `git diff --cached`) and `getRangeDiff(base, head)` (wrapping `git diff base..head`). Ensure the output is captured as a string suitable for passing to LLM contexts.",
            "status": "pending",
            "testStrategy": "In a temp repo, stage files and verify `getStagedDiff` captures changes. Verify `getRangeDiff` between two commits."
          },
          {
            "id": 3,
            "title": "Implement Cline Headless Execution Wrapper",
            "description": "Create the wrapper module for spawning Cline processes in a headless configuration.",
            "dependencies": [],
            "details": "Initialize `src/cline/index.ts`. Implement `runHeadless(prompt, opts)` using `child_process.spawn`. It should invoke `cline task new`, inject the prompt, and collect stdout/stderr streams without user intervention.",
            "status": "pending",
            "testStrategy": "Mock `child_process.spawn` to verify that `runHeadless` calls the cline binary with correct arguments and handles stream events."
          },
          {
            "id": 4,
            "title": "Implement Interactive Execution and Task Monitoring",
            "description": "Add support for interactive sessions and monitoring running tasks via the wrapper.",
            "dependencies": [
              3
            ],
            "details": "Implement `runInteractive` which inherits stdio for direct user interaction. Implement `followTask` which wraps `cline task view` to attach to and monitor the output of a specific running task ID.",
            "status": "pending",
            "testStrategy": "Integration test validating that `runInteractive` preserves TTY characteristics and `followTask` can attach to a mocked process stream."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Gating and GitHub Integration Modules",
        "description": "Develop the logic for parsing LLM verdicts and wrapping GitHub CLI operations.",
        "details": "1. `src/gating`: Implement `parseVerdict` to extract standardized headers (PASS/FAIL, ALLOW/BLOCK) and `shouldFail(verdict, policy)`. \n2. `src/github`: Implement `viewPr`, `diffPr`, and `submitReview` wrapping `gh` CLI commands. Ensure authentication state checks (pre-flight) are included.",
        "testStrategy": "Unit tests for `gating`: Feed various LLM text outputs (clean, noisy, malformed) to `parseVerdict`. Integration tests for `github`: Mock `gh` CLI output to verify parsing of PR details and diffs.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Gating Logic and Verdict Parsing",
            "description": "Develop the `src/gating` module to interpret LLM responses using regex to identify verdicts like PASS or FAIL within noisy output.",
            "dependencies": [],
            "details": "Create `src/gating/index.ts`. Implement `parseVerdict(text: string)` using regex (e.g., `/\\b(PASS|FAIL)\\b/i` or header matching) to handle standard and noisy LLM outputs. Implement `shouldFail(verdict, policy)` to determine boolean success based on the parsed result.",
            "status": "pending",
            "testStrategy": "Unit tests with sample LLM outputs (clean 'PASS', verbose 'I think this is a PASS', and negative 'FAIL') to verify regex robustness against edge cases."
          },
          {
            "id": 2,
            "title": "Implement GitHub CLI Read Wrappers",
            "description": "Create the foundation of the GitHub module to authenticate and read Pull Request information using the `gh` CLI.",
            "dependencies": [],
            "details": "Create `src/github/index.ts`. Implement `checkAuth()` to verify `gh auth status`. Implement `viewPr(prNumber)` to fetch JSON metadata via `gh pr view --json ...`. Implement `diffPr(prNumber)` to retrieve the raw diff content for analysis.",
            "status": "pending",
            "testStrategy": "Integration tests mocking the `gh` CLI stdout. Verify that JSON output from `gh` is correctly parsed into TypeScript interfaces and auth failures are caught."
          },
          {
            "id": 3,
            "title": "Implement GitHub CLI Write Wrappers",
            "description": "Extend the GitHub module to handle posting reviews, comments, and status updates back to the repository via the CLI.",
            "dependencies": [
              2
            ],
            "details": "Implement `submitReview(prNumber, body, event)` in `src/github`. Map internal verdicts to `gh pr review` flags (e.g., `--approve`, `--request-changes`, `--comment`). Ensure proper error handling for network or permissions issues.",
            "status": "pending",
            "testStrategy": "Mock `child_process.exec` to intercept `gh` commands. Verify that the correct command line arguments are constructed based on the input verdict and comments."
          }
        ]
      },
      {
        "id": 5,
        "title": "Develop Pre-commit Risk Review Gate Workflow",
        "description": "Create the script and prompt template for the pre-commit hook that blocks risky changes.",
        "details": "Create `pack/workflows/pre-commit-review.md` (the system prompt) and `pack/scripts/pre-commit.ts` (the runner). The runner should: \n1. Call `git.getStagedDiff`. \n2. If diff is empty/trivial, exit 0. \n3. Call `cline.runHeadless` with the diff and the review prompt. \n4. Parse result with `gating.parseVerdict`. \n5. Write artifact. \n6. Exit 1 if BLOCK, 0 if ALLOW.",
        "testStrategy": "E2E: Set up a dummy repo, install the hook script, stage a 'bad' file (simulated by prompt instruction or mock), and verify commit is rejected.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Risk Review System Prompt Template",
            "description": "Draft the `pre-commit-review.md` prompt that guides the LLM to analyze code changes for security and stability risks.",
            "dependencies": [],
            "details": "Create `pack/workflows/pre-commit-review.md`. The prompt needs to explicitly define categories of high-risk changes (e.g., credentials, massive deletions, complex logic changes without tests) and enforce a strict output format compatible with the gating module.",
            "status": "pending",
            "testStrategy": "Manual verification: Feed sample diffs (safe vs. risky) into the prompt using a playground or manual CLI call to ensure the LLM categorizes them correctly."
          },
          {
            "id": 2,
            "title": "Implement Pre-commit Orchestration Runner",
            "description": "Develop the TypeScript runner `pre-commit.ts` that orchestrates the flow between Git, Cline, and the Gating module.",
            "dependencies": [
              1
            ],
            "details": "Implement `pack/scripts/pre-commit.ts`. Steps: 1. Retrieve staged diff using `git` module. 2. Abort early if diff is empty. 3. Execute `cline.runHeadless` with the prompt from Subtask 1. 4. Use `gating.parseVerdict` to determine BLOCK/ALLOW. 5. Write artifacts and exit with code 1 (block) or 0 (allow).",
            "status": "pending",
            "testStrategy": "Unit test with mocks: Mock the `git` and `cline` modules. Verify that an ALLOW verdict returns exit code 0 and a BLOCK verdict returns exit code 1."
          },
          {
            "id": 3,
            "title": "Develop Git Hook Installation Logic",
            "description": "Create the mechanism to install and configure the pre-commit hook in the local `.git/hooks` directory.",
            "dependencies": [
              2
            ],
            "details": "Implement an installation routine (e.g., in a `setup` command) that writes an executable shell script to `.git/hooks/pre-commit`. This script must invoke the `pre-commit.ts` runner (via ts-node or node) ensuring the environment is correctly loaded.",
            "status": "pending",
            "testStrategy": "Integration test: Run the installer in a temporary git repository. Perform a `git commit` and verify the hook script triggers the runner."
          }
        ]
      },
      {
        "id": 6,
        "title": "Develop CI PR Review Gate Workflow",
        "description": "Create the workflow for CI pipelines that analyzes PR diffs and fails the build on critical issues.",
        "details": "Create `pack/workflows/ci-pr-review.md` and `pack/scripts/ci-review.ts`. The runner should: \n1. Detect environment (GH Actions, etc.). \n2. Fetch base/head SHAs. \n3. Get diff via `git` or `github` module. \n4. Run headless analysis. \n5. Generate `PASS/FAIL` verdict. \n6. Attach report as build artifact.",
        "testStrategy": "Integration: Simulate a CI environment variable set. Mock the diff input. Verify the script exits with non-zero code on 'FAIL' verdict.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement CI Environment Detection and Git History Hydration",
            "description": "Create the base script and implement logic to detect the CI environment and handle shallow git clones.",
            "dependencies": [],
            "details": "Initialize `pack/scripts/ci-review.ts`. Implement logic to read environment variables (e.g., GITHUB_EVENT_PATH, GITHUB_BASE_REF) to identify the context. Add conditional `git fetch` logic to ensure the repository has sufficient history to compute a diff between the PR branch and the target base branch.",
            "status": "pending",
            "testStrategy": "Unit test: Mock process.env variables for GH Actions and generic CI; verify the script correctly identifies the base and head SHAs."
          },
          {
            "id": 2,
            "title": "Create PR Review System Prompt and Diff Extraction",
            "description": "Define the AI instruction set for PR reviews and integrate the git diff extraction logic.",
            "dependencies": [
              1
            ],
            "details": "Create `pack/workflows/ci-pr-review.md` defining strict criteria for 'PASS' vs 'FAIL' (e.g., security risks, major bugs). Update the TS script to utilize the shared `git` module to extract the string diff between the resolved base and head commits.",
            "status": "pending",
            "testStrategy": "Manual verification: Ensure the generated markdown prompt contains the necessary constraints and that the diff extraction works on a local branch comparison."
          },
          {
            "id": 3,
            "title": "Integrate Headless Analysis Runner",
            "description": "Connect the script to the Cline headless execution mode to analyze the retrieved diff.",
            "dependencies": [
              2
            ],
            "details": "In `pack/scripts/ci-review.ts`, combine the diff content with the `ci-pr-review.md` prompt. Call `cline.runHeadless` to process the inputs. Implement a timeout mechanism to prevent CI hangs if the analysis takes too long.",
            "status": "pending",
            "testStrategy": "Integration test: Mock the Cline runner response. Verify that the script correctly constructs the prompt payload sent to the runner."
          },
          {
            "id": 4,
            "title": "Implement Verdict Enforcement and Artifact Reporting",
            "description": "Parse the analysis result to generate build artifacts and determine the process exit code.",
            "dependencies": [
              3
            ],
            "details": "Implement logic to parse the AI output for the verdict. Save the full analysis to `review-report.md`. If the verdict is FAIL, call `process.exit(1)`. Implement logic to print GitHub Actions annotations (e.g., `::error::`) if running in that environment.",
            "status": "pending",
            "testStrategy": "E2E test: Run the full script against a mock diff that contains a deliberate error. Verify the script exits with code 1 and generates the report file."
          }
        ]
      },
      {
        "id": 7,
        "title": "Develop Daily Changelog Generator Workflow",
        "description": "Implement the workflow to summarize recent commits into a changelog entry.",
        "details": "Create `pack/workflows/changelog.md` and `pack/scripts/generate-changelog.ts`. \n1. `git.getCommitLog` for the specified time window. \n2. Construct prompt with commit messages. \n3. Run `cline` to summarize. \n4. Append output to `CHANGELOG.md` using file I/O utils.",
        "testStrategy": "Integration: populate a dummy git history. Run the script. Verify `CHANGELOG.md` is created/appended with text matching the commit summaries.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Changelog Prompt Template",
            "description": "Create the markdown prompt file that instructs the LLM on how to summarize git commits into a user-friendly format.",
            "dependencies": [],
            "details": "Create the file `pack/workflows/changelog.md`. The prompt must instruct the model to analyze raw git commit messages, filter out low-level noise (e.g., merge commits, minor styling), group changes by category (Features, Fixes, Maintenance), and output a clean Markdown list ready for appending to a changelog.",
            "status": "pending",
            "testStrategy": "Manual verification: Feed the prompt a sample list of 10 commits manually and ensure the generated markdown output is concise and correctly formatted."
          },
          {
            "id": 2,
            "title": "Implement Changelog Generation Script",
            "description": "Develop the TypeScript script that automates the extraction of commits and the updating of the changelog file.",
            "dependencies": [
              1
            ],
            "details": "Create `pack/scripts/generate-changelog.ts`. This script should use `git.getCommitLog` to retrieve commits within a specified time window, load the template from `pack/workflows/changelog.md`, invoke `cline` with the constructed context, and finally append the returned summary to `CHANGELOG.md` using file I/O utilities.",
            "status": "pending",
            "testStrategy": "Integration test: Initialize a temporary git repo with dummy commits, run the script, and verify that `CHANGELOG.md` is successfully created or updated with the expected summary."
          }
        ]
      },
      {
        "id": 8,
        "title": "Develop Lint Sweep and Auto-Fix Workflow",
        "description": "Create a workflow that runs linters, identifies errors, and uses Cline to apply fixes.",
        "details": "Create `pack/workflows/lint-fix.md` and `pack/scripts/lint-sweep.ts`. \n1. Run user-provided lint command (e.g., `npm run lint`). \n2. Capture stderr/stdout. \n3. If failure, invoke `cline` with error log + relevant file context to generate a patch. \n4. Apply patch and re-run lint.",
        "testStrategy": "Integration: Create a file with a deliberate syntax error. Configure the script to run a linter. Verify the script invokes cline and the file is modified to fix the error.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Linter Execution Harness",
            "description": "Create the base script to execute user-defined lint commands and capture their output streams for analysis.",
            "dependencies": [],
            "details": "Initialize `pack/scripts/lint-sweep.ts`. Implement a function using `child_process.spawn` or `exec` to run the command passed via arguments (e.g., `npm run lint`). Capture `stdout` and `stderr` independently. Return a structured object containing the exit code and the full error logs string. Ensure the process does not terminate the parent script immediately on linter failure.",
            "status": "pending",
            "testStrategy": "Unit test: Mock a shell command that outputs specific text to stderr and exits with code 1. Verify the harness captures the text and returns the correct exit code."
          },
          {
            "id": 2,
            "title": "Design Auto-Fix System Prompt",
            "description": "Create the prompt template that instructs the LLM on how to generate machine-readable code fixes.",
            "dependencies": [],
            "details": "Create `pack/workflows/lint-fix.md`. Define the AI persona and instructions. Crucially, enforce a specific output format for the fixes, such as Unified Diff format or strict `<<<<SEARCH / ==== / >>>>REPLACE` blocks, to facilitate deterministic parsing. Include examples of error logs paired with correct diff responses.",
            "status": "pending",
            "testStrategy": "Manual verification: Feed the prompt with a sample lint error and code snippet into a playground to ensure the LLM outputs the requested format reliably."
          },
          {
            "id": 3,
            "title": "Implement AI Response Parsing and Patching Logic",
            "description": "Develop the logic to parse the LLM's response and apply the suggested code changes to the file system.",
            "dependencies": [
              1,
              2
            ],
            "details": "In `pack/scripts/lint-sweep.ts`, implement a parsing function that extracts the diff or code block from the Cline response (generated via `cline.runHeadless`). Use a library like `diff` or custom string manipulation to apply these changes to the target source files. Handle errors where the patch cannot be applied cleanly.",
            "status": "pending",
            "testStrategy": "Unit test: helper function `applyPatch(fileContent, patchString)`. Verify it correctly modifies a string based on a mock diff input."
          },
          {
            "id": 4,
            "title": "Implement Retry Loop and Verification Orchestrator",
            "description": "Combine components into a self-healing loop that runs the linter, attempts fixes, and verifies the result.",
            "dependencies": [
              3
            ],
            "details": "Finalize `pack/scripts/lint-sweep.ts`. Implement a loop: 1. Run Harness (Subtask 1). 2. If exit code 0, succeed. 3. If fail, invoke Cline with the Prompt (Subtask 2) and error logs. 4. Apply Patch (Subtask 3). 5. Decrement max-retries counter (e.g., max 3). 6. Repeat. Ensure the script exits with non-zero if the error persists after max retries.",
            "status": "pending",
            "testStrategy": "Integration test: Create a JS file with a known lint error (e.g., missing semicolon). Run the script. Verify the file is modified and the subsequent lint pass succeeds."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Pack Installation Module",
        "description": "Build the `install` module to bootstrap the workflow pack into target repositories.",
        "details": "Implement `src/install/index.ts`. \n1. `computePlan`: Determine which files need to be copied/created based on user selection. \n2. `installPack`: Copy files from `pack/` to `.clinerules/workflows` and `scripts/cline`. \n3. Ensure it respects `overwrite` policies and preserves existing configs.",
        "testStrategy": "Unit/Integration: Run install against a clean temp directory. Verify file structure is created. Run against an existing directory to test overwrite protection.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement computePlan for Installation Analysis",
            "description": "Create the logic to analyze the target repository and determine which files need to be installed or updated based on user selection.",
            "dependencies": [],
            "details": "Implement the `computePlan` function in `src/install/index.ts`. This function should accept the target directory path and selected workflows. It must scan existing paths (e.g., `.clinerules/workflows`) to identify conflicts. The output should be a structured plan object indicating which files to 'create', 'skip', or 'overwrite' to ensure the operation is idempotent.",
            "status": "pending",
            "testStrategy": "Unit test `computePlan` with mocked file system states (empty directory, partial installation, full conflict) to verify correct action classification."
          },
          {
            "id": 2,
            "title": "Implement installPack for File Operations",
            "description": "Develop the function to execute the installation plan by copying files and creating necessary directories.",
            "dependencies": [
              1
            ],
            "details": "Implement `installPack` in `src/install/index.ts` to execute the plan generated by `computePlan`. This function will handle physical file operations, copying assets from the internal `pack/` directory to `.clinerules/workflows` and `scripts/cline`. It must recursively create missing directories and apply necessary permissions (e.g., executable bits for scripts).",
            "status": "pending",
            "testStrategy": "Integration test: Run `installPack` against a temporary directory and verify that the file structure matches the source pack and that file contents are identical."
          }
        ]
      },
      {
        "id": 10,
        "title": "Create CLI Entry Point and End-to-End Validation",
        "description": "Expose the pack functionality via a main CLI entry point and validate the full flow.",
        "details": "Create `bin/cline-pack` (or similar) using a library like `commander` or `yargs`. Expose commands: `install`, `list`, `run <workflow-id>`. Wire up the `manifest`, `install`, and `cline` modules. Perform a full E2E test of the 'Pre-commit' flow from installation to execution.",
        "testStrategy": "Manual/E2E: Install the CLI globally (linked). Run `cline-pack install` in a test repo. Run `cline-pack run changelog`. Verify success.",
        "priority": "medium",
        "dependencies": [
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize CLI Framework and Entry Point",
            "description": "Set up the binary entry point using a library like commander or yargs to handle command-line argument parsing.",
            "dependencies": [],
            "details": "Create `bin/cline-pack.ts` and configure the node shebang. Initialize the CLI library (e.g., `commander`) to handle versioning, help generation, and global flags. Define the root command structure ensuring it is ready to accept specific subcommands like install and run.",
            "status": "pending",
            "testStrategy": "Execute the binary with `--help` and `--version` flags to ensure the CLI framework is correctly initialized and the executable is runnable."
          },
          {
            "id": 2,
            "title": "Implement Install, List, and Run Commands",
            "description": "Wire up the specific CLI subcommands to the internal modules for manifest handling, installation, and execution.",
            "dependencies": [
              1
            ],
            "details": "Implement the command handlers: `install` should invoke the install module logic; `list` should call `manifest.listWorkflows` and format the output to console; `run <id>` should lookup the workflow in the manifest and delegate execution to the `cline` module or specific script runner.",
            "status": "pending",
            "testStrategy": "Unit test command handlers by mocking the underlying modules (manifest/install/cline) to verify arguments are passed correctly from the CLI input."
          },
          {
            "id": 3,
            "title": "Perform End-to-End System Validation",
            "description": "Execute a full user journey test on a dummy repository to verify the integration of all components from installation to execution.",
            "dependencies": [
              2
            ],
            "details": "Create a temporary git repository. Run `cline-pack install` to set up hooks. Run `cline-pack list` to verify the registry. Execute `cline-pack run <workflow-id>` (e.g., pre-commit) with staged changes to verify system prompts, cline interactions, and final exit codes match expectations.",
            "status": "pending",
            "testStrategy": "Manual E2E test script: Setup a temp repo, link the CLI, run the full sequence of commands, and assert file system changes (artifacts created) and process exit codes."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-12-23T19:11:53.790Z",
      "updated": "2025-12-23T19:11:53.790Z",
      "description": "Tasks for master context"
    }
  }
}